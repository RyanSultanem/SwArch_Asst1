PHASE4:

1. The idea behind the design is that everything inherit from a base class called TA, which contains the basic information of all the classes such as name, and some common function such as the print function. In order to extend the library, one would need to look at the hierarchy and depending on the type that needs to be added to extend it, for example if there is a need to add a new operator, it would therefore inherit from unary or binary operator, and overloading the correct methods would allow a good use and good integration with the other classes. Same goes for the Primitive types for example.

2. The main design principle was to seperate the Primtive Types from the operators, therefore two classes inhertited from the base class TA, TAPrimitiveTypes and TAOperators. Both of those classes contains data depending on the type of data that they should return. After looking at PHASE3, Arrays and Pairs needed to be addded, and they actually did not contain data, but contained other types that contained the data. Therefore, a class was between the PrimitiveTypes and Operators and TA base class, called TAData. Now TAPair and TAArray actually inherit directly from TA, since they do not contains pure data, but other objects that at some point would contain TAData. This way we would allow TAPairs and TAArray to be nested or to create TArray of TAPairs for example as needed.

3. The main logic behind the project was, since everything inherits from TA, to use polymoprhism to write the logic once and make sure that at runtime the correct methods are called. For example the operators would actually contains TAData pointers objects as attributes, but actually passing them the correct inherited class. The virtual functions would be called correctly following the polymorphism logic. Base methods would be called correctly on their overloaded functions, and therefore the logic would match. This also allowed the fact to create nested operators, since operators contatins TAData which could be either PrimitiveType or Operator, but regardless, we would call evaluate on both operands, and polymoprhism would make sure that everything is called corrrectly without having to worry about what the actual object is. Also, all the TAData classes contains a value, but since all of the lower classes contains different types of data, I decided to create a void* value attribute, and on all the constructors, cast it to the corresponding type. This would allow us to use value  where needed without needing to know exactly the lower type, but simply when using TAData.
The way TAArray was implemented was using Templates instead of passing the type through another object. Eventhough this is not the way it was requested in the problem, I felt like this would result in nearly the same. I had though of another way to do it which would probably work, but I was out of the time. The idea was to create a singleton class that would act as a global variable that contained hashtable of all the types that were created at runtime. Each class would actually contain a .type() function, and each time a constructor is called it would add the type to the hashtable if it wasnt initially there. Now each time we want to create an array, since we should pass the argument via an object, therefore the type of the object would be in the table since it used the constructor. Now on the constructor of the array, we would call a virtual method that all the classes should implement, which is a method that returns the array of the corresponding type. So on the array constructor, we actually get the object itself from the hashtable, call .createArray method on that object, and it would return the correct array type. Our initial array could be a TA* that could therfore be casted to any lower class. This would be how I would implement in a better way.
